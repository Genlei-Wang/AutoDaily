这是一个**资深架构师（Architect）**级别的技术规格书（Technical Specification）。

---

# Technical Specification: AutoDaily Automation Engine

**Version:** 1.0.0
**Author:** Root Agent (Gemini)
**Target Platform:** Windows 7/10/11 (x86/x64)
**Tech Stack:** .NET Framework 4.7.2 (C#) | WinForms | Native Win32 API

## 1. 架构设计原则 (Architecture Principles)

1.  **Zero Dependency (零依赖)**: 严禁引入庞大的第三方库（如 Selenium, EmguCV）。所有核心功能必须基于 `.NET BCL` 和 `user32.dll` 实现。目标 EXE 体积 < 2MB。
2.  **Decoupling (解耦)**: UI 层、调度层（Scheduler）、执行层（Engine）必须严格分离。
3.  **Robustness (鲁棒性)**: 所有的 IO 操作、API 调用必须有完整的 Try-Catch 和日志记录。
4.  **Scalability (可扩展性)**: 数据存储结构必须支持“多任务”，虽然 V1 版本界面只暴露一个任务，但底层数据结构要为未来预留空间。

## 2. 系统架构图 (System Architecture)

```mermaid
graph TD
    A[UI Layer (WinForms)] -->|Commands| B[Task Manager (Controller)];
    B -->|Load/Save| C[Data Repository (JSON)];
    B -->|Schedule| D[Background Watchdog];
    B -->|Execute| E[Automation Engine];
    
    E -->|Hook/Simulate| F[Win32 API Wrapper];
    F -->|Interact| G[Target Application];
    
    D -.->|Event: SessionUnlock| B;
    H[Global Hotkey (F12)] -->|Interrupt| E;
```

---

## 3. 核心模块设计 (Core Modules)

### 3.1 Data Repository (数据层)
采用 JSON 文件存储，结构设计支持多任务列表。

*   **File**: `%AppData%\AutoDaily\tasks.json`
*   **Schema**:
    ```json
    {
      "version": "1.0",
      "tasks": [
        {
          "id": "uuid-gen-1",
          "name": "Morning Report",
          "schedule": {
            "enabled": true,
            "cron": "0 9 * * *",  // 简单的 Cron 表达式或 TimeOfDay
            "catchUp": true       // 是否开启“补卡”机制
          },
          "targetWindow": {
             "title": "xx Bank Client",
             "processName": "client.exe",
             "rect": { "w": 1024, "h": 768 } // 录制时的窗口尺寸
          },
          "actions": [ // 动作序列
            { "type": "Wait", "param": 2000 },
            { "type": "MouseMove", "x": 120, "y": 50, "relative": true },
            { "type": "MouseClick", "button": "Left" },
            { "type": "Input", "text": "2025-11-25" }
          ],
          "lastRun": "2025-11-25T09:01:00"
        }
      ]
    }
    ```

### 3.2 Automation Engine (执行引擎)
引擎是无状态的，负责解析 `actions` 序列并执行。

*   **Interface**: `IEngine`
*   **Key Method**: `Run(Task task, CancellationToken token)`
*   **Coordinate Strategy (坐标策略 - 核心)**:
    *   **Before Run**:
        1.  Find window handle by `processName` or `title`.
        2.  Check current `GetWindowRect`.
        3.  Execute `SetWindowPos` to resize window to `task.targetWindow.rect`.
        4.  Bring window to front (`SetForegroundWindow`).
    *   **During Run**:
        1.  Convert `Relative(x,y)` to `Screen(x,y)` based on current window position.
        2.  Call `SendInput` (user32.dll) for simulation.

### 3.3 Watchdog (调度守望者)
一个轻量级的后台服务类，不依赖 Windows Task Scheduler。

*   **Logic**:
    *   启动一个 `System.Timers.Timer` (Interval = 30s)。
    *   监听 `Microsoft.Win32.SystemEvents.SessionSwitch` (Handle Unlock events)。
*   **Algorithm**:
    ```csharp
    void CheckSchedule() {
        foreach (var task in tasks) {
            if (!task.Enabled) continue;
            
            bool isTime = Now >= task.ScheduleTime;
            bool notRunToday = task.LastRun.Date != Today;
            
            // 正常触发 OR 补卡触发
            if (isTime && notRunToday) {
                if (IsScreenLocked()) {
                    MarkPending(task); // 等待解锁后跑
                } else {
                    ExecuteTask(task);
                }
            }
        }
    }
    ```

### 3.4 Recorder (录制器)
基于全局钩子（Global Hooks）实现。

*   **Implementation**: 使用 `SetWindowsHookEx` (WH_MOUSE_LL, WH_KEYBOARD_LL)。
*   **Optimization**:
    *   **Debounce (防抖)**: 忽略小于 50ms 的微小抖动。
    *   **Merge (合并)**: 连续的 `MouseMove` 不需要记录几千个点，只需记录关键轨迹或仅记录 `Click` 前的最终坐标 (End Point)。**建议仅记录 Click/Type 事件及其前的短暂停顿，大幅精简数据。**

---

## 4. 工程结构推荐 (Project Structure)

```text
/AutoDaily.sln
  /Core
    /Models        (Task, Action, WindowInfo)
    /Services      (TaskService, ScheduleService)
    /Native        (User32.cs, Kernel32.cs - P/Invoke)
    /Engine        (Player.cs, Recorder.cs)
  /UI
    /Forms         (MainForm, OverlayForm)
    /Controls      (TaskCard, ToggleSwitch)
  /Program.cs      (Entry Point, Single Instance Mutex)
```

## 5. 关键技术难点与解决方案 (FAQ for Devs)

### Q1: 如何确保按 F12 一定能停下来？
**A:** 在执行引擎的循环中，每次执行 Action 前检查 `CancellationToken`。同时，F12 的 Global Hook 必须在一个独立的线程中运行，直接调用 `Cancel()`，不要在 UI 线程里等。

### Q2: 如果用户有两个显示器，窗口在副屏怎么办？
**A:** 我们的 `Relative Coordinate` 算法天然支持多屏。只要 `GetWindowRect` 返回的左上角坐标是正确的（哪怕是负数），`Window_Left + Relative_X` 算出来的屏幕绝对坐标就是正确的。

### Q3: WinForms 界面太丑，WPF 太大怎么办？
**A:** 坚持用 WinForms。引入 `GDI+` 简单重绘一下按钮（OnPaint），画个圆角和阴影即可。不要引入几百 MB 的 WPF 依赖或者第三方 UI 库。保持 EXE < 2MB 是硬指标。

---

## 6. 拓展性规划 (Roadmap)

由于我们在 **3.1 Data Repository** 中已经将 Task 设计为 Array：
*   **V1.0**: UI 仅显示并操作 `tasks[0]`。
*   **V1.x**: UI 增加“+”按钮，允许用户创建多个任务。
*   **V2.0**: 增加 `Action` 类型，支持简单的逻辑判断（如 "Wait Until Image Appear"），只需扩展 `Engine` 的解析逻辑，无需重构架构。

---