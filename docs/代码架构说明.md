# AutoDaily 代码架构说明

## 📖 项目概述

**AutoDaily** 是一个面向银行/国企职员的桌面自动化工具，用于自动完成每日重复的日报操作。

### 核心功能
1. **录制功能**：记录用户的鼠标点击、键盘输入等操作
2. **回放功能**：按照录制的操作自动执行一遍
3. **定时调度**：每天在指定时间自动执行任务
4. **开机自启**：电脑开机后自动启动软件（可选）

---

## 🏗️ 项目结构

```
AutoDaily/
├── Core/                    # 核心业务逻辑
│   ├── Engine/             # 引擎层（录制和回放）
│   │   ├── Recorder.cs     # 录制器：记录用户操作
│   │   └── Player.cs        # 播放器：执行录制的操作
│   ├── Models/              # 数据模型
│   │   ├── Task.cs          # 任务模型（包含动作序列、调度信息等）
│   │   └── TaskData.cs      # 任务数据容器
│   ├── Native/              # Windows API 封装
│   │   ├── User32.cs        # 用户界面相关API（窗口、鼠标、键盘）
│   │   └── Kernel32.cs      # 系统内核API（进程、模块等）
│   └── Services/            # 业务服务层
│       ├── TaskService.cs   # 任务数据存储服务
│       ├── ScheduleService.cs  # 定时调度服务
│       └── LogService.cs    # 日志服务
├── UI/                      # 用户界面
│   ├── Forms/               # 窗口
│   │   ├── MainForm.cs      # 主窗口（录制、运行、定时设置）
│   │   ├── OverlayForm.cs   # 录制时的悬浮提示窗口
│   │   └── RunningOverlayForm.cs  # 运行时的进度显示窗口
│   └── Controls/            # 自定义控件
│       └── ToggleSwitch.cs  # 开关控件（定时运行开关）
└── Program.cs               # 程序入口

```

---

## 🔍 核心模块详解

### 1. 录制器 (Recorder.cs)

**作用**：像录像机一样，记录用户的所有操作。

**工作原理**：
- 使用 Windows 的**全局钩子（Hook）**技术，监听整个系统的鼠标和键盘事件
- 当用户点击鼠标或按下键盘时，钩子会捕获这些事件
- 将事件转换为**动作对象（Action）**，保存到列表中

**关键代码逻辑**：
```csharp
// 1. 安装钩子（开始监听）
_mouseHook = User32.SetWindowsHookEx(User32.WH_MOUSE_LL, _mouseProc, ...);
_keyboardHook = User32.SetWindowsHookEx(User32.WH_KEYBOARD_LL, _keyboardProc, ...);

// 2. 钩子回调函数（当有鼠标/键盘事件时触发）
private IntPtr MouseHookProc(int nCode, IntPtr wParam, IntPtr lParam)
{
    // 记录鼠标点击位置（使用相对坐标，适应窗口移动）
    AddAction(new Action { Type = "MouseClick", X = x, Y = y, Relative = true });
}

// 3. 卸载钩子（停止监听）
User32.UnhookWindowsHookEx(_mouseHook);
```

**为什么用相对坐标？**
- 如果记录的是屏幕绝对坐标（如：点击屏幕(500, 300)），当窗口位置改变时，点击就会错位
- 使用相对坐标（如：点击窗口内(100, 50)），即使窗口移动，也能准确点击

---

### 2. 播放器 (Player.cs)

**作用**：像播放器一样，按照录制的操作自动执行。

**工作原理**：
1. 找到目标窗口（通过窗口标题或进程名）
2. 恢复窗口位置和大小（确保与录制时一致）
3. 激活窗口（确保窗口在前台）
4. 逐个执行录制的动作：
   - 移动鼠标到指定位置
   - 点击鼠标
   - 输入文字
   - 等待一段时间

**关键代码逻辑**：
```csharp
// 1. 查找目标窗口
IntPtr hwnd = FindTargetWindow(task.TargetWindow);

// 2. 恢复窗口状态
AdjustWindow(hwnd, task.TargetWindow.Rect, task.TargetWindow);

// 3. 激活窗口
User32.SetForegroundWindow(hwnd);

// 4. 执行动作序列
foreach (var action in task.Actions)
{
    ExecuteAction(action, hwnd, token);
}
```

**为什么需要平滑移动鼠标？**
- 直接瞬间移动鼠标到目标位置，某些软件会检测为“机器人操作”
- 分多步平滑移动，模拟人类操作，避免被检测

---

### 3. 定时调度服务 (ScheduleService.cs)

**作用**：像一个闹钟，在指定时间自动执行任务。

**工作原理**：
- 使用 `System.Timers.Timer` 定时检查当前时间
- 如果当前时间 >= 设定时间，且今天还没执行过，就触发任务

**智能调度策略**：
- **距离目标时间 > 5分钟**：每60秒检查一次（节省资源）
- **距离目标时间 1-5分钟**：每10秒检查一次（提高响应速度）
- **距离目标时间 < 1分钟**：每1秒检查一次（确保精确触发）

**防重复触发机制**：
- 检查今天是否已执行过（`LastRun` 日期）
- 检查上次触发时间间隔（防止同一分钟内重复触发）

**开机自启实现**：
- 通过写入 Windows 注册表 `HKCU\Software\Microsoft\Windows\CurrentVersion\Run`
- 无需管理员权限（使用当前用户注册表）

---

### 4. 任务数据服务 (TaskService.cs)

**作用**：负责保存和读取任务数据。

**数据存储**：
- 文件位置：`exe同目录/Data/tasks.json`
- 格式：JSON（使用 .NET Framework 内置的 `JavaScriptSerializer`）
- 内容：任务列表、动作序列、调度信息、窗口信息等

**为什么用 JSON？**
- 人类可读（出问题时可以手动查看和修改）
- 跨平台兼容（虽然目前只支持 Windows）
- 无需第三方库（使用系统自带组件）

---

### 5. 主窗口 (MainForm.cs)

**作用**：用户界面，提供录制、运行、定时设置等功能。

**UI 设计理念**：
- **极简设计**：只有3个核心区域（录制/运行按钮、定时开关、状态显示）
- **大按钮**：方便非技术人员操作
- **Apple 风格**：圆角、卡片式布局、清晰的视觉层次

**关键功能**：
1. **录制流程**：
   - 点击"录制" → 最小化窗口 → 开始监听操作 → 点击"停止" → 保存动作序列

2. **运行流程**：
   - 点击"运行" → 隐藏主窗口 → 显示进度窗口 → 执行动作 → 完成后恢复主窗口

3. **定时运行**：
   - 开启开关 → 设置时间 → 自动设置开机自启 → 关闭窗口时隐藏到托盘（不退出）

**托盘驻留机制**：
- 当用户点击关闭按钮，且定时任务已开启时：
  - 不退出程序，而是隐藏窗口
  - 显示系统托盘图标
  - 弹出气泡提示"软件正在后台运行"

---

### 6. Windows API 封装 (User32.cs / Kernel32.cs)

**作用**：封装 Windows 底层 API，让 C# 代码可以调用系统功能。

**为什么需要？**
- C# 是高级语言，无法直接调用 Windows 底层函数
- 通过 `DllImport` 特性，声明外部 DLL 函数
- 使用 `P/Invoke`（平台调用）技术，实现跨语言调用

**关键 API 说明**：
- `SetWindowsHookEx`：安装全局钩子（监听鼠标/键盘）
- `SendInput`：模拟鼠标点击和键盘输入
- `FindWindow`：查找窗口
- `SetForegroundWindow`：激活窗口
- `SetWindowPos`：设置窗口位置和大小

---

## 🔄 完整工作流程

### 录制流程
```
用户点击"录制" 
  → Recorder.StartRecording() 
  → 安装全局钩子 
  → 用户操作（点击、输入） 
  → 钩子捕获事件 
  → 转换为Action对象 
  → 保存到列表 
  → 用户点击"停止" 
  → 卸载钩子 
  → TaskService.SaveTasks() 
  → 保存到JSON文件
```

### 运行流程
```
用户点击"运行" 
  → Player.RunAsync() 
  → 查找目标窗口 
  → 恢复窗口状态 
  → 激活窗口 
  → 逐个执行动作 
  → 更新进度显示 
  → 完成后更新LastRun时间
```

### 定时执行流程
```
ScheduleService 定时器触发 
  → CheckSchedule() 
  → 检查当前时间是否到达设定时间 
  → 检查今天是否已执行 
  → 触发任务回调 
  → MainForm.OnScheduledTaskTriggered() 
  → 自动执行 StartRunning()
```

---

## 🛠️ 技术要点

### 1. 相对坐标 vs 绝对坐标
- **绝对坐标**：屏幕上的固定位置（如：点击屏幕(500, 300)）
- **相对坐标**：相对于窗口的位置（如：点击窗口内(100, 50)）
- **本项目使用相对坐标**：适应窗口位置变化

### 2. 全局钩子（Hook）
- Windows 提供的机制，可以拦截系统级事件
- 即使窗口失去焦点，也能捕获鼠标/键盘事件
- 需要正确释放，否则可能导致系统资源泄漏

### 3. 线程安全
- UI 操作必须在主线程（UI线程）执行
- 使用 `InvokeRequired` 和 `Invoke` 确保跨线程安全

### 4. 资源释放
- 实现 `IDisposable` 接口，确保钩子、定时器等资源正确释放
- 使用 `using` 语句或 `try-finally` 确保资源释放

---

## 📝 代码规范

### 命名规范
- **类名**：PascalCase（如：`TaskService`）
- **方法名**：PascalCase（如：`StartRecording()`）
- **私有字段**：`_camelCase`（如：`_taskService`）
- **常量**：`UPPER_CASE`（如：`DEFAULT_CHECK_INTERVAL_MS`）

### 代码组织
- 使用 `#region` 组织代码块（构造函数、私有方法、公共方法等）
- 添加 XML 注释（`/// <summary>`），方便生成文档
- 提取魔法数字为常量，提高可读性

### 错误处理
- 使用 `try-catch` 捕获异常
- 记录日志（使用 `LogService`），不静默吞掉错误
- 关键错误抛出异常，非关键错误记录日志

---

## 🎯 优化建议

### 已完成的优化
1. ✅ 提取魔法数字为常量（提高可读性）
2. ✅ 添加详细的 XML 注释（方便维护）
3. ✅ 统一代码风格（命名、组织）
4. ✅ 改进错误处理（统一使用 LogService）
5. ✅ 实现 IDisposable（确保资源释放）

### 未来可优化方向
1. 支持多任务（目前只支持单个任务）
2. 支持条件判断（如：如果弹窗出现，则点击"确定"）
3. 支持循环执行（重复执行N次）
4. 支持变量和参数化（如：每次输入不同的账号）
5. 支持图像识别（不依赖窗口标题，通过截图识别按钮）

---

## 📚 相关技术文档

- [Windows API 文档](https://docs.microsoft.com/en-us/windows/win32/api/)
- [.NET Framework P/Invoke](https://docs.microsoft.com/en-us/dotnet/standard/native-interop/pinvoke)
- [Windows Hooks](https://docs.microsoft.com/en-us/windows/win32/winmsg/about-hooks)

---

## 💡 常见问题

**Q: 为什么录制后运行不准确？**
A: 可能是窗口位置或大小改变了。确保目标窗口的位置和大小与录制时一致。

**Q: 定时任务不执行？**
A: 检查软件是否